  % exclusion_rationale = {}

@inproceedings{10.1145/3196398.3196434,
  author = {Mahmoudi, Mehran and Nadi, Sarah},
  title = {The Android Update Problem: An Empirical Study},
  year = {2018},
  isbn = {9781450357166},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3196398.3196434},
  doi = {10.1145/3196398.3196434},
  abstract = {
    Many phone vendors use Android as their underlying OS, but often extend it to add new functionality and to make it compatible with their specific phones. When a new version of Android is released, phone vendors need to merge or re-apply their customizations and changes to the new release. This is a difficult and time-consuming process, which often leads to late adoption of new versions. In this paper, we perform an empirical study to understand the nature of changes that phone vendors make, versus changes made in the original development of Android. By investigating the overlap of different changes, we also determine the possibility of having automated support for merging them. We develop a publicly available tool chain, based on a combination of existing tools, to study such changes and their overlap. As a proxy case study, we analyze the changes in the popular community-based variant of Android, LineageOS, and its corresponding Android versions. We investigate and report the common types of changes that occur in practice. Our findings show that 83\% of subsystems modified by LineageOS are also modified in the next release of Android. By taking the nature of overlapping changes into account, we assess the feasibility of having automated tool support to help phone vendors with the Android update problem. Our results show that 56\% of the changes in LineageOS have the potential to be safely automated.
  },
  booktitle = {Proceedings of the 15th International Conference on Mining Software Repositories},
  pages = {220–230},
  numpages = {11},
  keywords = {Android, merge conflicts, software evolution, software merging},
  location = {Gothenburg, Sweden},
  series = {MSR '18},
  exclusion_rationale = {
    This research focuses on vendor specific modifications to the Android OS based on LineageOS. While it's interesting, it's not relevant to using analytics, doesn't touch on apps, and doesn't discuss software-in-use quality aspects.
  }
}

@inproceedings{10.1145/3052973.3052990,
    author = {Taylor, Vincent F. and Martinovic, Ivan},
    title = {To Update or Not to Update: Insights From a Two-Year Study of Android App Evolution},
    year = {2017},
    isbn = {9781450349444},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/3052973.3052990},
    doi = {10.1145/3052973.3052990},
    abstract = {Although there are over 1,900,000 third-party Android apps in the Google Play Store,
    little is understood about how their security and privacy characteristics, such as
    dangerous permission usage and the vulnerabilities they contain, have evolved over
    time. Our research is two-fold: we take quarterly snapshots of the Google Play Store
    over a two-year period to understand how permission usage by apps has changed; and
    we analyse 30,000 apps to understand how their security and privacy characteristics
    have changed over the same two-year period. Extrapolating our findings, we estimate
    that over 35,000 apps in the Google Play Store ask for additional dangerous permissions
    every three months. Our statistically significant observations suggest that free apps
    and popular apps are more likely to ask for additional dangerous permissions when
    they are updated. Worryingly, we discover that Android apps are not getting safer
    as they are updated. In many cases, app updates serve to increase the number of distinct
    vulnerabilities contained within apps, especially for popular apps. We conclude with
    recommendations to stakeholders for improving the security of the Android ecosystem.},
    booktitle = {Proceedings of the 2017 ACM on Asia Conference on Computer and Communications Security},
    pages = {45–57},
    numpages = {13},
    keywords = {android, vulnerability, app, longitudinal, permission},
    location = {Abu Dhabi, United Arab Emirates},
    series = {ASIA CCS '17},
    exclusion_rationale = {
      The research work is interesting in terms of studying how Android apps tended to become more vulnerable and also to put the user's information at risk. They applied the OWASP Mobile Top 10 (from 2014, despite the 2016 list predating the paper being published~\url{https://owasp.org/www-project-mobile-top-10/}). They also encourage app stores to consider checking for vulnerabilities when apps are uploaded to the app store and the separation of permissions for libraries from those used by the core app. However I've decided the paper isn't sufficiently relevant to include in my thesis currently as:
      - It's dated
      - It doesn't actually answer the update question posed in the title, at least not from the end user's perspective
      - The focus is on security and privacy rather than the use of mobile analytics, or on reliability aspects.
      I may yet decide to include it depending on the focus my final thesis takes.
    }
}

@article{10.1109/MPRV.2011.1,
    author = {Butler, Margaret},
    title = {Android: Changing the Mobile Landscape},
    year = {2011},
    issue_date = {January 2011},
    publisher = {IEEE Educational Activities Department},
    address = {USA},
    volume = {10},
    number = {1},
    issn = {1536-1268},
    url = {https://doi.org/10.1109/MPRV.2011.1},
    doi = {10.1109/MPRV.2011.1},
    abstract = {The mobile phone landscape changed last year with the introduction of smart phones
    running Android, a platform marketed by Google. Android phones are the first credible
    threat to the iPhone market. Not only did Google target the same consumers as iPhone,
    it also aimed to win the hearts and minds of mobile application developers. On the
    basis of market share and the number of available apps, Android is a success.},
    journal = {IEEE Pervasive Computing},
    month = jan,
    pages = {4–7},
    numpages = {4},
    keywords = {Apple App Store, Android, iPhone, BlackBerry, App Inventor for Android, Technovation, Android, App Inventor for Android, iPhone, Apple App Store, BlackBerry, Technovation},
    exclusion_rationale = {Too early in the evolution of Android, seems also factually incorrect as Android launched in 2008. Not relevant, however it is cited by various papers of interest to my research, hence it's here to show I chose to exclude it.},
}

@inproceedings{musuvathi2008_finding_and_reproducing_heisenbugs,
  title={Finding and Reproducing Heisenbugs in Concurrent Programs.},
  author={Musuvathi, Madanlal and Qadeer, Shaz and Ball, Thomas and Basler, Gerard and Nainar, Piramanayagam Arumuga and Neamtiu, Iulian},
  year = {2008},
  exclusion_rationale = {TBD, I've yet to read the paper, hence this is on hold and not yet suitable to include in the thesis.}
}

@inproceedings{weissenbacher2012explaining,
  title={Explaining heisenbugs},
  author={Weissenbacher, Georg},
  booktitle={Runtime Verification},
  volume={9333},
  year={2012},
  url = {https://publik.tuwien.ac.at/files/PubDat_244157.pdf},
  abstract = {
    Heisenbugs are complex software bugs that alter their behaviour when attempts to isolate them are made. The term heisenbug is a pun on the name of physicist Werner Heisenberg and refers to bugs whose analysis is complicated by the probe effect, an unintended alteration of system behaviour caused by an observer.

    Heisenbugs are most prevalent in concurrent systems, where the interplay of multiple threads running on multi-core processors leads to intricate effects not anticipated by the developer. Faced with a heisenbug, it is the tedious task of the programmer to reproduce the erroneous behaviour and analyse its cause before the bug can be fixed.

    It is exactly in these situations that automated analyses are the most desirable. Model checkers and systematic testing tools, for instance, can automatically reproduce erroneous executions manifesting the bug. The subsequent inspection of the error trace, however, is still a time-consuming process that requires substantial insight. 

    My group developed two approaches to analyse erroneous executions and explain concurrency bugs, attacking the problem from different angles. In both cases, the goal is to allow the programmer to focus on the essence of the bug rather than the specifics of the failed execution. On the one hand, we use data mining to extract explanations from execution logs by juxtaposing successful runs of the program with failed executions. The resulting explanations highlight potentially problematic data dependencies that frequently occur in failing executions. The second approach relies on static analysis and automated reasoning to obtain a slice of an erroneous execution trace that reflects the core of the problem.

    After introducing both approaches, I will discuss their advantages as well as shortcomings, and explain differences regarding soundness and comprehensibility using case studies and empirical results.
  }
  exclusion_rationale = {This is solely an abstract. While it explains heisenbugs well I don't think I need to include an explanation of them. If I do, this will become a relevant reference.}
}

@InProceedings{10.1007/978-3-642-13166-0_32,
    author="Brito, Miguel A.
    and de S{\'a}-Soares, Filipe",
    editor="Lytras, Miltiadis D.
    and Ordonez De Pablos, Patricia
    and Avison, David
    and Sipior, Janice
    and Jin, Qun
    and Leal, Walter
    and Uden, Lorna
    and Thomas, Michael
    and Cervai, Sara
    and Horner, David",
    title="Computer Programming: Fail Fast to Learn Sooner",
    booktitle="Technology Enhanced Learning. Quality of Teaching and Educational Reform",
    year="2010",
    publisher="Springer Berlin Heidelberg",
    address="Berlin, Heidelberg",
    pages="223--229",
    abstract="Computer programming is not only to know about the languages or the processes, it is essentially to know how to do it. This involves a constructivist approach in learning. For a newbie in computer programming it is hard to understand the difference between know-about disciplines and the know-how-to-do-it ones. This leads to failure because when they understand they aren't able to solve a programming problem it is usually too late to catch all the time meanwhile lost. Our solution is to get them to fail soon enough. This way they still have time to recover from an eventually bad start.",
    isbn="978-3-642-13166-0",
    exclusion_rationale = {The research is on undergraduate learning and how to help them learn in time. It's not on my topic at all.}
}

@INPROCEEDINGS{6624018,  
  author={Herzig, Kim and Zeller, Andreas},  
  booktitle={2013 10th Working Conference on Mining Software Repositories (MSR)},  
  title={The impact of tangled code changes}, 
  year={2013},
  volume={},
  number={}, 
  pages={121-130},
  abstract={When interacting with version control systems, developers often commit unrelated or loosely related code changes in a single transaction. When analyzing the version history, such tangled changes will make all changes to all modules appear related, possibly compromising the resulting analyses through noise and bias. In an investigation of five open-source Java projects, we found up to 15\% of all bug fixes to consist of multiple tangled changes. Using a multi-predictor approach to untangle changes, we show that on average at least 16.6\% of all source files are incorrectly associated with bug reports. We recommend better change organization to limit the impact of tangled changes.},  
  keywords={}, 
  doi={10.1109/MSR.2013.6624018}, 
  ISSN={2160-1860},
  month={May},
  exclusion_rationale = {The authors claim there is no impact of tangled commits ``Tangled change sets do not cause trouble in development." I disagree - they may cause trouble with reverting a subset of the changes in the commit. They may also increase the code review overhead as the reviewer needs to consider multiple purposes of the commit concurrently, etc.},
}

@INPROCEEDINGS{
  7886923,  
  author={Ray, Baishakhi and Hellendoorn, Vincent and Godhane, Saheel and Tu, Zhaopeng and Bacchelli, Alberto and Devanbu, Premkumar}, 
  booktitle={2016 IEEE/ACM 38th International Conference on Software Engineering (ICSE)},
  title={On the "Naturalness" of Buggy Code},  
  year={2016}, 
  volume={},  
  number={}, 
  pages={428-439},
  abstract={
    Real software, the kind working programmers produce by the kLOC to solve real-world problems, tends to be “natural”, like speech or natural language; it tends to be highly repetitive and predictable. Researchers have captured this naturalness of software through statistical models and used them to good effect in suggestion engines, porting tools, coding standards checkers, and idiom miners. This suggests that code that appears improbable, or surprising, to a good statistical language model is “unnatural” in some sense, and thus possibly suspicious. In this paper, we investigate this hypothesis. We consider a large corpus of bug fix commits (ca. 7,139), from 10 different Java projects, and focus on its language statistics, evaluating the naturalness of buggy code and the corresponding fixes. We find that code with bugs tends to be more entropic (i.e. unnatural), becoming less so as bugs are fixed. Ordering files for inspection by their average entropy yields cost-effectiveness scores comparable to popular defect prediction methods. At a finer granularity, focusing on highly entropic lines is similar in cost-effectiveness to some well-known static bug finders (PMD, FindBugs) and or- dering warnings from these bug finders using an entropy measure improves the cost-effectiveness of inspecting code implicated in warnings. This suggests that entropy may be a valid, simple way to complement the effectiveness of PMD or FindBugs, and that search-based bug-fixing methods may benefit from using entropy both for fault-localization and searching for fixes.},  
  keywords={},
  doi={10.1145/2884781.2884848},
  ISSN={1558-1225}, 
  month={May},
  exclusion_rationale = {This looks of interest, however it's currently off-topic. Might be of interest for future work?}
}

@inproceedings{10.1145/320719.322582,
    author = {Rekimoto, Jun},
    title = {Time-Machine Computing: A Time-Centric Approach for the Information Environment},
    year = {1999},
    isbn = {1581130759},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    url = {https://doi.org/10.1145/320719.322582},
    doi = {10.1145/320719.322582},
    abstract = {This paper describes the concept of Time-Machine Computing (TMC), a time-centric approach
    to organizing information on computers. A system based on Time-Machine Computing allows
    a user to visit the past and the future states of computers. When a user needs to
    refer to a document that he/she was working on at some other time, he/she can travel
    in the time dimension and the system restores the computer state at that time. Since
    the user's activities on the system are automatically archived, the user's daily workspace
    is seamlessly integrated into the information archive. The combination of spatial
    information management of the desktop metaphor and time traveling allows a user to
    organize and archive information without being bothered by folder hierarchies or the
    file classification problems that are common in today's desktop environments. TMC
    also provides a mechanism for linking multiple applications and external information
    sources by exchanging time information. This paper describes the key features of TMC,
    a time-machine desktop environment called “TimeScape,” and several time-oriented application
    integration examples.},
    booktitle = {Proceedings of the 12th Annual ACM Symposium on User Interface Software and Technology},
    pages = {45–54},
    numpages = {10},
    keywords = {time-machine computing, information visualization, desktop environment, time traveling, inter-application communication, document management},
    location = {Asheville, North Carolina, USA},
    series = {UIST '99},
    exclusion_rationale = {This is an interesting concept and time-machines might be useful when testing mobile analytics, however it's too far removed from my actual PhD research to include.}
}

@INPROCEEDINGS{9058278,  
  author={Jain, Parita and Sharma, Anupam and Aggarwal, Puneet Kumar},  
  booktitle={2020 10th International Conference on Cloud Computing, Data Science   Engineering (Confluence)},  
  title={Key Attributes for a Quality Mobile Application}, 
  year={2020},  
  volume={}, 
  number={}, 
  pages={50-54}, 
  abstract={
    The innovative advancement of cell phones, the significance of the Internet in the present society and the blasting market of the mobile devices have upset the mobile software programming altogether known as the product quality of portable intuitive gadgets. The mobile software programming gets increasingly competent and complex, which enables designers to apply entrenched quality strategies and models, from the work area of software programming advancement to mobile software programming. But still, mobile software programming moreover still has its portable explicit qualities, comparing models and techniques that must be balanced for its use in the larger domain. In the following research, some of the key attributes that must be incorporated and taken care for developing a portable quality mobile applications are identified. The key attributes determined by investigating before developed quality models which allows enhancing knowledge that can be drifted in the near future.},  
  keywords={},  
  doi={10.1109/Confluence47617.2020.9058278},
  ISSN={},
  month={Jan},
  exclusion_rationale = {Excludes various key quality factors including security, stability, and performance. The article is too short to provide sufficient depth to apply it. In short, I'm not convinced their model is adequate.}
}

@ARTICLE{59,
  author={Boehm, B. W.}, 
  journal={Computer},  
  title={A spiral model of software development and enhancement},  
  year={1988},
  volume={21},
  number={5},
  pages={61-72},
  abstract={
    A short description is given of software process models and the issues they address. An outline is given of the process steps involved in the spiral model, an evolving risk-driven approach that provides a framework for guiding the software process, and its application to a software project is shown. A summary is given of the primary advantages and implications involved in using the spiral model and the primary difficulties in using it at its current incomplete level of elaboration.}, 
  keywords={},  
  doi={10.1109/2.59}, 
  ISSN={1558-0814}, 
  month={May},
  exclusion_rationale = {I'd hoped to find a discussion on the uncertainties in software development, it was partly addressed in this article but not in a way that seemed would apply to mobile app development (the paper predates them by many years).}
}

@online{raygun_homepage,
  title = {Error monitoring and crash reporting},
  url = {https://raygun.com/platform/crash-reporting},
  abstract = {
    Monitor and fix production errors with ease. Control the chaos around solving software bugs. Quickly diagnose problems in your codebase, enjoy faster development cycles and make sure users are having error free experiences.
  },
  claims = {
    Zero in on the root cause and replicate issues quickly with code-level diagnostics. Unlock end-to-end visibility into the errors and crashes that are detrimental to your customers’ experience. Stop relying on log files, or support tickets with incomplete information and solve issues quickly. See the full stack trace, environment, browser, version, OS, class name, host and more. Even identify the release or commit that introduced the issue. Filter through your errors by date, time, version, tag, host, OS, browser, custom tags and more. Reduce noise with configurable filters for machine name, version, IP address, hostname and more.
  }
}