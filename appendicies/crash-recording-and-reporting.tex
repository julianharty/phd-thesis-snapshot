\chapter{Crash recording and reporting [in Android]}~\label{app:crash-recording-and-reporting-in-android}
Fixing crashes is hard especially if the developers do not have any visibility into them. 


Google Android developers reported a new developer service ``Android Application Error Reports" as part of Android 2.2, known as Froyo. Two sentences were all that was provided:~\emph{``New bug reporting feature for Android Market apps enables developers to receive crash and freeze reports from their users. The reports will be available when they log into their publisher account."}~\citep{android2010_froyo_highlights_new_developer_services}.

\textbf{COULD-DO} Add notes on the clues I found on how Google implement their approach.

Android includes a class, \texttt{DropBoxManager} which enqueues chunks of data from various sources including application crashes. As the documentations for the class says \emph{`` You can think of this as a persistent, system-wide, blob-oriented "logcat"."}~\citep{android_dropboxmanager}. The documentation also explains other system services and debugging tools may scan and upload these entries for processing.


\href{https://github.com/operando/Android-Command-Note}{adb shell dumpsys dropbox}

Crash reports comprise:
\begin{itemize}
    \item A stack trace, generated at runtime. % using information. QQ is this gleaned from the source code or from runtime, both, a mix?
    \item An optional message, added in the source code
    \item Optional additional, custom, data intended to provide contextual information. The custom data may range from information recorded for this specific crash to general information such as the release of the app, the device model, and so on. Some or all of the contextual information may be generated by the crash reporting mechanism e.g. within the SDK, or as part of the platform.
    \item Optional breadcrumbs generated by the running software correlated with a stack trace \emph{iff} a crash occurs. Intended to help trace back from the crash to conditions that led to the crash occurring. % e.g. https://raygun.com/documentation/language-guides/android/crash-reporting/advanced-setup/ 
\end{itemize}

Symbol files may be needed in order to decode stack traces. 

Similar mechanisms may be used to report errors as well as crashes, for instance for `handled' exceptions.

Crash reporting libraries are responsible for capture, safekeeping, transmission, and management of crash reports. The captures depend on where the crash is reported and when the crash reporting code is active. Broadly the reports may be local to the app or local to the device. If a crash occurs before the crash reporting library is active the crash may cause the app to crash \emph{without the crash being handled \textbf{or} reported}. Designers of crash reporting libraries therefore aim to initialise the library as early as practical in the application's runtime lifecycle. The Firebase team at Google devised a clever mechanism to initialise the Firebase SDK library before the \texttt{OnCreate()} method is called through using a ContentProvider~\footnote{\url{https://developer.android.com/guide/topics/providers/content-provider-basics}} and ContentProviders are one of the core building blocks of the Android operating system~\citep{firebaseblog2016_how_does_firebase_initialize_on_android}. Firebase Crase Reporting also implements an \texttt{UncaughtExceptionHandler}, which is standard practice for crash handlers in Java code. The author freely admitted misusing the concept of ContentProvider in their blog post, a topic discussed next.

\phantomsection
\label{Firebase-SDK-ContentProvider}
Although the SDK for Firebase was designed to minimise code developers needed to write there are various circumstances when developers need to take control and explicitly write code to configure and initialise the firebase SDK. These are discussed in~\citep{firebaseblog2017_take_control_of_your_firebase_init_on_android}. In~\citep{techyourchance2021_contentprovider_in_android_libraries_considered_harmful}, the author rebukes Firebase's choice of using a ContentProvider for initialisation and cites Legal (GDPR), development, maintenance, and performance challenges together with the shift in complexity for developers who use Firebase, from writing a few lines of initialisation code, to dealing with an essential configuration file \texttt{google-services.json}. As of \nth{21} July 2021 there are 3,533 search results for the file on Stack Overflow~\footnote{\url{https://stackoverflow.com/search?tab=relevance&q=google-services.json}.}. Perhaps this is a good example of needing to beware of unintended consequences?~\footnote{\url{https://en.wikipedia.org/wiki/Unintended_consequences}}
% See also Google's adoption of App Startup using ContentProvider as a design pattern in Android Jetpack https://developer.android.com/topic/libraries/app-startup

Despite the Firebase SDK being initialised so early in the app's lifecycle some crashes have been reported in Android Vitals that have not been reported by Firebase Crash Reporting~\citep{so2021_shankar_strange_crash_in_cronetDynamite.apk} where the crash is in \texttt{CronetDynamite.apk}. This file appears to be for a networking library called cronet, released as part of the the Google Chromium project~\citep{android_cronet_library}. In unpublished correspondence with one of the Google Product Managers for Google Play Console and Android Vitals they explained that there will be crashes that occur when an app starts up that only appear in Android Vitals and not in Crashlytics (the example used in the discussion at the time, the principle applies to any of the current in-app crash reporting offerings)~\footnote{Based on the author's understanding of Android and failure reporting it may be possible for apps to obtain and report these sorts of crashes through scanning the on-device location the platform mobile analytics processes. To do so may need system permissions.}.

For mobile apps in particular, where connectivity isn't always available and free-to-use, the library may need to store crash reports and associated data locally on the device for a period. There may be a finite limit on the number of crash reports that will be stored by the SDK. Some SDKs allow this to be configured by the app developer; for example the Raygun for Android SDK~\footnote{\url{https://github.com/MindscapeHQ/raygun4android}} provides \texttt{RaygunClient.setMaxReportsStoredOnDevice(amount)} and limits the maximum to 64 in their opensource SDK~\footnote{So developers could modify the SDK to change the hardcoded limit, doing so may change the behaviour of the transmission sufficiently to require supporting changes server-side.}. Where to send the reports may, optionally, be configurable. For example the Raygun for Android SDK allows developers to set the destination endpoint by using \texttt{RaygunClient.setCustomCrashReportingEndpoint(String url)}.

Various SDKs include additional forms of reporting, for instance Real User Monitoring (RUM), Performance measurement and reporting, \emph{etc.} % e.g. https://raygun.com/documentation/language-guides/android/real-user-monitoring/advanced-setup/

Who performs the analytics and what influence do the developers have?

The reporting aspects are also vital, and offerings vary in their functionality, capabilities, and ease of use. Sorting, filtering, aggregating (and de-aggregating) 
% https://raygun.com/documentation/product-guides/crash-reporting/filtering-error-groups/
% https://raygun.com/documentation/product-guides/crash-reporting/

Tool integration and data integration are also vital.


\section{Discussions on Stack Overflow}
\begin{itemize}
    \item \href{https://stackoverflow.com/questions/66471628/detecting-crashes-when-someone-else-implement-my-sdk}{Detecting crashes when someone else implement my sdk}
    \item \href{https://stackoverflow.com/questions/67138663/how-to-make-fake-ndk-crashes-in-android-in-order-to-test-crashlytics-integration}{How to make fake NDK crashes in Android in order to test Crashlytics integration?}
    \item \href{How do I obtain crash-data from my Android application?}{How do I obtain crash-data from my Android application?} - a relatively early SO question that has lots of answers.
    \item \href{https://stackoverflow.com/questions/20763011/android-saving-logs-on-every-run-for-crash-report}{Android saving logs on every run for crash report}
    \item \href{https://stackoverflow.com/questions/63190868/masive-error-after-updating-to-firebase-crashlytics-sdk}{Masive error after updating to Firebase Crashlytics SDK} - Google developers acknowledged there were issues and issued a new release that they believed fixed the issue \href{https://github.com/firebase/firebase-android-sdk/issues/2013}{java.util.concurrent.RejectedExecutionException in Crashlytics \#2013} They did not elaborate.
    \item \href{https://stackoverflow.com/questions/64381093/crash-logged-java-lang-runtimeexception-that-only-happens-in-android-8-1-api}{Crash logged 'java.lang.RuntimeException' that only happens in android 8.1 (API 27), stack trace is not pointing to our code, how to debug?}
    \item \href{https://stackoverflow.com/questions/59926756/report-all-android-crashes-to-own-api}{Report all Android crashes to own API} and a suggested approach \url{https://stackoverflow.com/a/64382151/340175}
    \item What ACRA records in their recent SDK release \url{https://github.com/ACRA/acra/wiki/ReportContent}
    \item \href{https://stackoverflow.com/questions/3378550/android-crash-reporting-library-pre-froyo}{Android crash reporting library (pre Froyo)}
    \item A StackOverflow discussion on how to read the files for ANRs and tombstones on Android devices~\citep{learner2011_so_how_to_access_anrs_and_tombstones}. The question is from 2011 and in terms of the Android ecosystem, lots has changed including restrictions in access permissions and in the operating system. Nonetheless, the questions and answers provide information on where the data on ANRs and similar runtime data, are stored.
    \item A StackOverflow discussion on the Android adb shell dumpsys tool~\url{https://stackoverflow.com/questions/11201659/whats-the-android-adb-shell-dumpsys-tool-and-what-are-its-benefits}. The adb dumpsys command can report on the dropbox service as well as many other services. 
\end{itemize}

\subsection{Additional sources}
\begin{itemize}
    \item An old opensource project from 2010, \href{https://code.google.com/archive/p/android-send-me-logs/}{Google Code Archive - Android, send me logs!} that parsed the on-device logs with the aim of detecting force closes (which often occur after an unhandled exception or ANR). From reading the source code it's not clear how it actually determines an app has been force-closed. Note it's based on a longer running project, ~\href{https://code.google.com/archive/p/android-log-collector/}{Google Code Archive - Android Log Collector} which continued until 2012. For anyone who wishes to revitalise this work, the newest version of Android Log Collector may be well worth incorporating.
    
    \item Source of Android's~\href{https://android.googlesource.com/platform/frameworks/base/+/master/services/core/java/com/android/server/DropBoxManagerService.java}{DropBoxManagerService.java}. There's an interesting comment in the source code on the design they've implemented: \emph{``A single circular buffer (a la logcat) would be simpler, but this way we can handle fat/bursty data (like 1MB+ bugreports, 300KB+ kernel crash dumps, and 100KB+ ANR reports) without swamping small, well-behaved data streams (event statistics, profile data, etc)."}~\footnote{There's some relatively simple analysis of this source code class file online \url{https://www.programmersought.com/article/66131178515/}.}
    
    \item \texttt{adb logcat} is a practical mechanism to inspect and query the various Android logs on a device. \citep{khan2019_medium_filtering_adb_logcat_efficiently} provides practical tips that may help with using \texttt{adb logcat} efficiently and effectively, for instance to query the device's crash log. Android reference documentation for logcat~\footnote{\url{https://developer.android.com/studio/command-line/logcat}}, and in particular the section on~\href{https://developer.android.com/studio/command-line/logcat#alternativeBuffers}{Viewing alternative log buffers} lists the various logs accessible using logcat.
    
    Google publishes the source code for the system crash\_reporter in the Android platform~\citep{android_platform_system_crash_reporter}. It includes various details on how and when crashes are reported and uploaded. See also \href{https://git.halogenos.org/halogenOS/android\_system\_core/src/commit/33c59358525052c788a2d170d326b8b1cf810dd1/metricsd/metrics_collector.cc}{metrics\_collector.cc} from HalogenOS/android\_system\_core. Note HalogenOS is based on the Android Open Source Project and shares much of the source code.
\end{itemize}

A native crash was reported in \href{Kiwix Android - Issue 896}{https://github.com/kiwix/kiwix-android/issues/896} for the Kiwix Android project. The issue includes an extract from an Android log file with various details related to the crash dump. Two in particular are relevant to the topic of crash recording and reporting: 

\begin{itemize}
    \item \texttt{ /system/bin/tombstoned: Tombstone written to: /data/tombstones//tombstone\_08}: confirming where the tombstone files are written, and
    
    \item \texttt{DropBoxManagerService: Dropping: data\_app\_native\_crash (2918 > 0 bytes)}: where DropBoxManagerService records it's discarding details of the native crash (it doesn't contain any clues why it's doing so).

\end{itemize}

